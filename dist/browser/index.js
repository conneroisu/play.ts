var j=Math.PI,v=Math.PI*2,_V=Math.PI/2,z8=Math.PI/4,ZV=v,S8=Math.E,C8=(1+Math.sqrt(5))/2,U=(V,J,N)=>{if(J>N)[J,N]=[N,J];return Math.min(Math.max(V,J),N)},B=(V,J,N)=>{if(isNaN(V)||isNaN(J)||isNaN(N))return NaN;if(N===0)return V;if(N===1)return J;if(V===1/0&&J===-1/0)return NaN;if(V===-1/0&&J===1/0)return NaN;if(V===1/0)return 1/0;if(J===1/0)return 1/0;if(V===-1/0)return-1/0;if(J===-1/0)return-1/0;return V+(J-V)*N},GV=(V,J,N,$,M)=>{if(N===J)return 1/0;return $+(V-J)*(M-$)/(N-J)},QV=(V,J,N)=>{if(N===J){if(V===J)return NaN;return 1/0}return(V-J)/(N-J)},w8=(V,J,N)=>{let $=U((N-V)/(J-V),0,1);return $*$*(3-2*$)},f8=(V,J,N)=>{let $=U((N-V)/(J-V),0,1);return $*$*$*($*($*6-15)+10)},WV=(V)=>{return V*180/j},t=(V)=>{return V*j/180},v8=(V)=>{return V>0?1:V<0?-1:0},x8=(V)=>{return V-Math.floor(V)},b8=(V,J,N)=>{let $=N-J;return $===0?J:J+((V-J)%$+$)%$},E=(V,J)=>({x:V,y:J}),R=(V,J)=>({x:V.x+J.x,y:V.y+J.y}),O=(V,J)=>({x:V.x-J.x,y:V.y-J.y}),D=(V,J)=>({x:V.x*J===-0?0:V.x*J,y:V.y*J===-0?0:V.y*J}),EV=(V,J)=>({x:V.x/J,y:V.y/J}),u8=(V,J)=>{return V.x*J.x+V.y*J.y},b=(V)=>{return Math.sqrt(V.x*V.x+V.y*V.y)},m8=(V)=>{return V.x*V.x+V.y*V.y},S=(V)=>{let J=V.x*V.x+V.y*V.y;if(J===0)return E(0,0);if(!isFinite(J))return E(NaN,NaN);let N=Math.sqrt(J);return{x:V.x/N,y:V.y/N}},u=(V,J)=>{let N=V.x-J.x,$=V.y-J.y;return Math.sqrt(N*N+$*$)},XV=(V)=>{return Math.atan2(V.y,V.x)},YV=(V,J=1)=>({x:Math.cos(V)*J,y:Math.sin(V)*J}),UV=(V,J,N)=>({x:B(V.x,J.x,N),y:B(V.y,J.y,N)}),FV=(V,J)=>{let N=Math.cos(J),$=Math.sin(J);return{x:V.x*N-V.y*$,y:V.x*$+V.y*N}},Y0=(V,J,N)=>({x:V,y:J,z:N}),qV=(V,J)=>({x:V.x+J.x,y:V.y+J.y,z:V.z+J.z}),U0=(V,J)=>({x:V.x-J.x,y:V.y-J.y,z:V.z-J.z}),DV=(V,J)=>({x:V.x*J,y:V.y*J,z:V.z*J}),F0=(V,J)=>({x:V.x/J,y:V.y/J,z:V.z/J}),HV=(V,J)=>{return V.x*J.x+V.y*J.y+V.z*J.z},LV=(V,J)=>({x:V.y*J.z-V.z*J.y,y:V.z*J.x-V.x*J.z,z:V.x*J.y-V.y*J.x}),e=(V)=>{return Math.sqrt(V.x*V.x+V.y*V.y+V.z*V.z)},y8=(V)=>{return V.x*V.x+V.y*V.y+V.z*V.z},BV=(V)=>{let J=e(V);return J>0?F0(V,J):Y0(0,0,0)},jV=(V,J)=>{return e(U0(V,J))},RV=(V,J,N)=>({x:B(V.x,J.x,N),y:B(V.y,J.y,N),z:B(V.z,J.z,N)}),h8=()=>({elements:[1,0,0,0,1,0,0,0,1]}),g8=(V,J,N,$,M,K,_,Z,G)=>({elements:[V,J,N,$,M,K,_,Z,G]}),p8=(V,J)=>{let N=V.elements,$=J.elements;return{elements:[N[0]*$[0]+N[1]*$[3]+N[2]*$[6],N[0]*$[1]+N[1]*$[4]+N[2]*$[7],N[0]*$[2]+N[1]*$[5]+N[2]*$[8],N[3]*$[0]+N[4]*$[3]+N[5]*$[6],N[3]*$[1]+N[4]*$[4]+N[5]*$[7],N[3]*$[2]+N[4]*$[5]+N[5]*$[8],N[6]*$[0]+N[7]*$[3]+N[8]*$[6],N[6]*$[1]+N[7]*$[4]+N[8]*$[7],N[6]*$[2]+N[7]*$[5]+N[8]*$[8]]}},d8=(V,J)=>{let N=V.elements;return{x:N[0]*J.x+N[1]*J.y+N[2],y:N[3]*J.x+N[4]*J.y+N[5]}},k=Math.sin,m=Math.cos,c8=Math.tan,r8=Math.asin,n8=Math.acos,s8=Math.atan,Q8=Math.atan2,o8=Math.sinh,l8=Math.cosh,i8=Math.tanh,s=Math.abs,a8=Math.ceil,y=Math.floor,t8=Math.round,e8=Math.trunc,V0=Math.sqrt,P=Math.pow,V7=Math.exp,J7=Math.log,N7=Math.log2,$7=Math.log10,C=Math.min,x=Math.max;var F=(V,J,N)=>({r:U(V,0,255),g:U(J,0,255),b:U(N,0,255)}),q0=(V,J,N,$)=>({r:U(V,0,255),g:U(J,0,255),b:U(N,0,255),a:U($,0,1)}),H=(V,J,N)=>({h:(V%360+360)%360,s:U(J,0,100),l:U(N,0,100)}),OV=(V,J,N,$)=>({h:(V%360+360)%360,s:U(J,0,100),l:U(N,0,100),a:U($,0,1)}),I=(V)=>{let J=V.r/255,N=V.g/255,$=V.b/255,M=Math.max(J,N,$),K=Math.min(J,N,$),_=M-K,Z=0,G=0,Q=(M+K)/2;if(_!==0)switch(G=Q>0.5?_/(2-M-K):_/(M+K),M){case J:Z=((N-$)/_+(N<$?6:0))/6;break;case N:Z=(($-J)/_+2)/6;break;case $:Z=((J-N)/_+4)/6;break}return{h:Z*360,s:G*100,l:Q*100}},L=(V)=>{let J=V.h/360,N=V.s/100,$=V.l/100,M=(W,X,Y)=>{if(Y<0)Y+=1;if(Y>1)Y-=1;if(Y<0.16666666666666666)return W+(X-W)*6*Y;if(Y<0.5)return X;if(Y<0.6666666666666666)return W+(X-W)*(0.6666666666666666-Y)*6;return W};if(N===0){let W=Math.round($*255);return F(W,W,W)}let K=$<0.5?$*(1+N):$+N-$*N,_=2*$-K,Z=M(_,K,J+0.3333333333333333),G=M(_,K,J),Q=M(_,K,J-0.3333333333333333);return F(Math.round(Z*255),Math.round(G*255),Math.round(Q*255))},PV=(V)=>{let J=(N)=>{let $=Math.round(U(N,0,255)).toString(16);return $.length===1?"0"+$:$};return`#${J(V.r)}${J(V.g)}${J(V.b)}`},AV=(V)=>{let J=V.replace("#",""),N=parseInt(J,16);if(J.length===3){let _=N>>8&15,Z=N>>4&15,G=N&15;return F(_*17,Z*17,G*17)}let $=N>>16&255,M=N>>8&255,K=N&255;return F($,M,K)},kV=(V,J,N)=>({r:B(V.r,J.r,N),g:B(V.g,J.g,N),b:B(V.b,J.b,N)}),IV=(V,J,N)=>{let $=V.h,M=J.h,K=M-$;if(K>180);else if(K<-180)M+=360;return{h:(B($,M,N)%360+360)%360,s:B(V.s,J.s,N),l:B(V.l,J.l,N)}},D0=(V,J)=>{let N=I(V),$=H(N.h,N.s,N.l+J);return L($)},TV=(V,J)=>{return D0(V,-J)},H0=(V,J)=>{let N=I(V),$=H(N.h,N.s+J,N.l);return L($)},zV=(V,J)=>{return H0(V,-J)},SV=(V,J)=>{let N=I(V),$=H(N.h+J,N.s,N.l);return L($)},CV=(V)=>{let J=Math.round(0.299*V.r+0.587*V.g+0.114*V.b);return F(J,J,J)},wV=(V)=>({r:255-V.r,g:255-V.g,b:255-V.b}),_7=(V,J)=>{let N=259*(J+255)/(255*(259-J));return F(U(N*(V.r-128)+128,0,255),U(N*(V.g-128)+128,0,255),U(N*(V.b-128)+128,0,255))},fV=(V)=>{let J=I(V),N=H(J.h+180,J.s,J.l);return L(N)},vV=(V)=>{let J=I(V),N=L(H(J.h+120,J.s,J.l)),$=L(H(J.h+240,J.s,J.l));return[N,$]},xV=(V,J=30)=>{let N=I(V),$=L(H(N.h+J,N.s,N.l)),M=L(H(N.h-J,N.s,N.l));return[$,M]},Z7=(V)=>{let J=I(V),N=L(H(J.h+150,J.s,J.l)),$=L(H(J.h+210,J.s,J.l));return[N,$]},G7=(V)=>{let J=I(V),N=L(H(J.h+90,J.s,J.l)),$=L(H(J.h+180,J.s,J.l)),M=L(H(J.h+270,J.s,J.l));return[N,$,M]},L8=(V,J)=>{let N=V.r-J.r,$=V.g-J.g,M=V.b-J.b;return Math.sqrt(N*N+$*$+M*M)},Q7=(V,J)=>{let N=Math.sqrt(195075);return 1-L8(V,J)/N},bV={white:F(255,255,255),black:F(0,0,0),red:F(255,0,0),green:F(0,255,0),blue:F(0,0,255),yellow:F(255,255,0),cyan:F(0,255,255),magenta:F(255,0,255),gray:F(128,128,128),lightGray:F(192,192,192),darkGray:F(64,64,64),orange:F(255,165,0),purple:F(128,0,128),pink:F(255,192,203),brown:F(165,42,42),transparent:q0(0,0,0,0)},L0=(V)=>{return`rgb(${Math.round(V.r)}, ${Math.round(V.g)}, ${Math.round(V.b)})`},B0=(V)=>{return`rgba(${Math.round(V.r)}, ${Math.round(V.g)}, ${Math.round(V.b)}, ${V.a})`},j0=(V)=>{return`hsl(${Math.round(V.h)}, ${Math.round(V.s)}%, ${Math.round(V.l)}%)`},R0=(V)=>{return`hsla(${Math.round(V.h)}, ${Math.round(V.s)}%, ${Math.round(V.l)}%, ${V.a})`};var uV=typeof window!=="undefined"&&window.requestAnimationFrame||((V)=>setTimeout(V,16)),c=(V)=>V,O0=(V)=>V*V,P0=(V)=>V*(2-V),A0=(V)=>{return V<0.5?2*V*V:-1+(4-2*V)*V},k0=(V)=>V*V*V,I0=(V)=>{return 1+--V*V*V},T0=(V)=>{return V<0.5?4*V*V*V:1-4*(1-V)*(1-V)*(1-V)},B8=(V)=>V*V*V*V,j8=(V)=>{return 1- --V*V*V*V},R8=(V)=>{return V<0.5?8*V*V*V*V:1-8*--V*V*V*V},O8=(V)=>V*V*V*V*V,P8=(V)=>{return 1+--V*V*V*V*V},A8=(V)=>{return V<0.5?16*V*V*V*V*V:1+16*--V*V*V*V*V},z0=(V)=>{return 1-m(V*j/2)},S0=(V)=>{return k(V*j/2)},C0=(V)=>{return 0.5*(1-m(j*V))},w0=(V)=>{return V===0?0:P(2,10*(V-1))},f0=(V)=>{return V===1?1:1-P(2,-10*V)},v0=(V)=>{if(V===0)return 0;if(V===1)return 1;return V<0.5?0.5*P(2,20*V-10):0.5*(2-P(2,-20*V+10))},x0=(V)=>{return 1-V0(1-V*V)},b0=(V)=>{return V0(1- --V*V)},u0=(V)=>{return V<0.5?0.5*(1-V0(1-4*V*V)):0.5*(V0(1-(2*V-2)*(2*V-2))+1)},m0=(V)=>{return 2.70158*V*V*V-1.70158*V*V},y0=(V)=>{return 1+2.70158*P(V-1,3)+1.70158*P(V-1,2)},h0=(V)=>{return V<0.5?P(2*V,2)*(7.189819*V-2.5949095)/2:(P(2*V-2,2)*(3.5949095*(V*2-2)+2.5949095)+2)/2},g0=(V)=>{let J=2*j/3;return V===0?0:V===1?1:-P(2,10*V-10)*k((V*10-10.75)*J)},p0=(V)=>{let J=2*j/3;return V===0?0:V===1?1:P(2,-10*V)*k((V*10-0.75)*J)+1},d0=(V)=>{let J=2*j/4.5;return V===0?0:V===1?1:V<0.5?-(P(2,20*V-10)*k((20*V-11.125)*J))/2:P(2,-20*V+10)*k((20*V-11.125)*J)/2+1},c0=(V)=>{return 1-d(1-V)},d=(V)=>{if(V<0.36363636363636365)return 7.5625*V*V;else if(V<0.7272727272727273)return 7.5625*(V-=0.5454545454545454)*V+0.75;else if(V<0.9090909090909091)return 7.5625*(V-=0.8181818181818182)*V+0.9375;else return 7.5625*(V-=0.9545454545454546)*V+0.984375},r0=(V)=>{return V<0.5?(1-d(1-2*V))/2:(1+d(2*V-1))/2},mV={linear:c,easeInQuad:O0,easeOutQuad:P0,easeInOutQuad:A0,easeInCubic:k0,easeOutCubic:I0,easeInOutCubic:T0,easeInQuart:B8,easeOutQuart:j8,easeInOutQuart:R8,easeInQuint:O8,easeOutQuint:P8,easeInOutQuint:A8,easeInSine:z0,easeOutSine:S0,easeInOutSine:C0,easeInExpo:w0,easeOutExpo:f0,easeInOutExpo:v0,easeInCirc:x0,easeOutCirc:b0,easeInOutCirc:u0,easeInBack:m0,easeOutBack:y0,easeInOutBack:h0,easeInElastic:g0,easeOutElastic:p0,easeInOutElastic:d0,easeInBounce:c0,easeOutBounce:d,easeInOutBounce:r0},k8=(V,J,N)=>({time:V,deltaTime:J,frame:N});class J0{running=!1;startTime=0;lastTime=0;frameCount=0;callbacks=[];start(){if(this.running)return;this.running=!0,this.startTime=performance.now(),this.lastTime=this.startTime,this.frameCount=0,this.loop()}stop(){this.running=!1}onFrame(V){return this.callbacks.push(V),()=>{let J=this.callbacks.indexOf(V);if(J>-1)this.callbacks.splice(J,1)}}loop(){if(!this.running)return;let V=performance.now(),J=V-this.lastTime,N=V-this.startTime,$=k8(N,J,this.frameCount);this.callbacks.forEach((M)=>M($)),this.lastTime=V,this.frameCount++,uV(()=>this.loop())}}class N0{startValue;endValue;duration;easing;onUpdate;onComplete;startTime=0;running=!1;constructor(V,J,N,$=c,M,K){this.startValue=V,this.endValue=J,this.duration=N,this.easing=$,this.onUpdate=M,this.onComplete=K}start(){if(this.running)return;this.running=!0,this.startTime=performance.now(),this.update()}stop(){this.running=!1}update(){if(!this.running)return;let J=performance.now()-this.startTime,N=U(J/this.duration,0,1),$=this.easing(N),M=this.startValue+(this.endValue-this.startValue)*$;if(this.onUpdate(M),N>=1)this.running=!1,this.onComplete?.();else uV(()=>this.update())}}var n0=(V,J,N,$=c,M,K)=>{let _=new N0(V,J,N,$,M,K);return _.start(),_},yV=(V)=>{return new Promise((J)=>setTimeout(J,V))},hV=(V,J=c,N,$)=>{return n0(0,1,V,J,N,$)};class $0{value;target;velocity=0;stiffness;damping;mass;onUpdate;running=!1;constructor(V,J=0.1,N=0.8,$=1,M){this.value=V,this.target=V,this.stiffness=J,this.damping=N,this.mass=$,this.onUpdate=M}setTarget(V){if(this.target=V,!this.running)this.start()}setValue(V){this.value=V,this.velocity=0,this.onUpdate(this.value)}start(){if(this.running)return;this.running=!0,this.update()}stop(){this.running=!1}update(){if(!this.running)return;let J=-this.stiffness*(this.value-this.target)/this.mass;if(this.velocity+=J,this.velocity*=this.damping,this.value+=this.velocity,this.onUpdate(this.value),Math.abs(this.value-this.target)<0.001&&Math.abs(this.velocity)<0.001)this.value=this.target,this.velocity=0,this.onUpdate(this.value),this.running=!1;else uV(()=>this.update())}}var gV=(V,J=0.1,N=0.8,$=1,M)=>{return new $0(V,J,N,$,M)};class o{seed_;constructor(V=Date.now()){this.seed_=V}next(){return this.seed_=(this.seed_*1664525+1013904223)%4294967296,this.seed_/4294967296}seed(V){this.seed_=V}int(V,J){return y(this.next()*(J-V+1))+V}float(V,J){return this.next()*(J-V)+V}bool(){return this.next()>0.5}choice(V){if(V.length===0)throw new Error("Cannot choose from empty array");return V[this.int(0,V.length-1)]}sign(){return this.bool()?1:-1}angle(){return this.float(0,Math.PI*2)}inCircle(){let V=this.angle(),J=Math.sqrt(this.next());return E(Math.cos(V)*J,Math.sin(V)*J)}onCircle(){let V=this.angle();return E(Math.cos(V),Math.sin(V))}gaussian(V=0,J=1){if(this.hasNextGaussian)return this.hasNextGaussian=!1,this.nextGaussian*J+V;let N=this.next(),$=this.next(),M=Math.sqrt(-2*Math.log(N))*Math.cos(2*Math.PI*$),K=Math.sqrt(-2*Math.log(N))*Math.sin(2*Math.PI*$);return this.nextGaussian=K,this.hasNextGaussian=!0,M*J+V}hasNextGaussian=!1;nextGaussian=0}class M0{hash(V){return V=(V>>16^V)*73244475,V=(V>>16^V)*73244475,V=V>>16^V,V/4294967296}hash2(V,J){return this.hash(V+J*57)}hash3(V,J,N){return this.hash(V+J*57+N*113)}interpolate(V,J,N){return V+N*N*(3-2*N)*(J-V)}noise1D(V){let J=y(V),N=V-J,$=this.hash(J),M=this.hash(J+1);return this.interpolate($,M,N)}noise2D(V,J){let N=y(V),$=y(J),M=V-N,K=J-$,_=this.hash2(N,$),Z=this.hash2(N+1,$),G=this.hash2(N,$+1),Q=this.hash2(N+1,$+1),W=this.interpolate(_,Z,M),X=this.interpolate(G,Q,M);return this.interpolate(W,X,K)}noise3D(V,J,N){let $=y(V),M=y(J),K=y(N),_=V-$,Z=J-M,G=N-K,Q=this.hash3($,M,K),W=this.hash3($+1,M,K),X=this.hash3($,M+1,K),Y=this.hash3($+1,M+1,K),p=this.hash3($,M,K+1),X0=this.hash3($+1,M,K+1),E8=this.hash3($,M+1,K+1),X8=this.hash3($+1,M+1,K+1),Y8=this.interpolate(Q,W,_),U8=this.interpolate(X,Y,_),F8=this.interpolate(p,X0,_),q8=this.interpolate(E8,X8,_),D8=this.interpolate(Y8,U8,Z),H8=this.interpolate(F8,q8,Z);return this.interpolate(D8,H8,G)}}class K0{noise;octaves;persistence;lacunarity;constructor(V=new M0,J=4,N=0.5,$=2){this.noise=V,this.octaves=J,this.persistence=N,this.lacunarity=$}noise1D(V){let J=0,N=1,$=1,M=0;for(let K=0;K<this.octaves;K++)J+=this.noise.noise1D(V*$)*N,M+=N,N*=this.persistence,$*=this.lacunarity;return J/M}noise2D(V,J){let N=0,$=1,M=1,K=0;for(let _=0;_<this.octaves;_++)N+=this.noise.noise2D(V*M,J*M)*$,K+=$,$*=this.persistence,M*=this.lacunarity;return N/K}noise3D(V,J,N){let $=0,M=1,K=1,_=0;for(let Z=0;Z<this.octaves;Z++)$+=this.noise.noise3D(V*K,J*K,N*K)*M,_+=M,M*=this.persistence,K*=this.lacunarity;return $/_}}class _0{permutation;p;constructor(V){this.permutation=[];for(let J=0;J<256;J++)this.permutation[J]=J;if(V!==void 0){let J=new o(V);for(let N=255;N>0;N--){let $=J.int(0,N);[this.permutation[N],this.permutation[$]]=[this.permutation[$],this.permutation[N]]}}else for(let J=255;J>0;J--){let N=Math.floor(Math.random()*(J+1));[this.permutation[J],this.permutation[N]]=[this.permutation[N],this.permutation[J]]}this.p=[];for(let J=0;J<512;J++)this.p[J]=this.permutation[J&255]}fade(V){return V*V*V*(V*(V*6-15)+10)}grad(V,J,N,$){let M=V&15,K=M<8?J:N,_=M<4?N:M===12||M===14?J:$;return((M&1)===0?K:-K)+((M&2)===0?_:-_)}noise1D(V){return this.noise3D(V,0,0)}noise2D(V,J){return this.noise3D(V,J,0)}noise3D(V,J,N){let $=Math.floor(V)&255,M=Math.floor(J)&255,K=Math.floor(N)&255;V-=Math.floor(V),J-=Math.floor(J),N-=Math.floor(N);let _=this.fade(V),Z=this.fade(J),G=this.fade(N),Q=this.p[$]+M,W=this.p[Q]+K,X=this.p[Q+1]+K,Y=this.p[$+1]+M,p=this.p[Y]+K,X0=this.p[Y+1]+K;return this.lerp(G,this.lerp(Z,this.lerp(_,this.grad(this.p[W],V,J,N),this.grad(this.p[p],V-1,J,N)),this.lerp(_,this.grad(this.p[X],V,J-1,N),this.grad(this.p[X0],V-1,J-1,N))),this.lerp(Z,this.lerp(_,this.grad(this.p[W+1],V,J,N-1),this.grad(this.p[p+1],V-1,J,N-1)),this.lerp(_,this.grad(this.p[X+1],V,J-1,N-1),this.grad(this.p[X0+1],V-1,J-1,N-1))))}lerp(V,J,N){return J+V*(N-J)}}var A=new o,pV=new _0,dV=new K0,h=(V,J)=>{return A.int(V,J)},r=(V,J)=>{return A.float(V,J)},cV=()=>{return A.bool()},rV=(V)=>{return A.choice(V)},nV=()=>{return A.sign()},sV=()=>{return A.angle()},oV=()=>{return A.inCircle()},lV=()=>{return A.onCircle()},iV=(V=0,J=1)=>{return A.gaussian(V,J)},aV=(V)=>{A.seed(V)},s0=(V,J)=>{if(V.length!==J.length)throw new Error("Choices and weights arrays must have the same length");if(V.length===0)throw new Error("Cannot choose from empty array");let N=J.reduce((K,_)=>K+_,0),$=Math.random()*N,M=0;for(let K=0;K<V.length;K++)if(M+=J[K],$<=M)return V[K];return V[V.length-1]},tV=(V)=>{let J=[...V];for(let N=J.length-1;N>0;N--){let $=h(0,N);[J[N],J[$]]=[J[$],J[N]]}return J},eV=()=>{return{r:h(0,255),g:h(0,255),b:h(0,255)}},V1=(V=0,J=360,N=0,$=100,M=0,K=100)=>{return{h:r(V,J),s:r(N,$),l:r(M,K)}},J1=(V,J,N)=>{let $=[];for(let M=0;M<V;M++)$.push(r(J,N));return $},N1=(V,J=1,N=2)=>{let $=[],M=new Array(N).fill(0);$.push([...M]);for(let K=0;K<V;K++){for(let _=0;_<N;_++)M[_]+=(Math.random()-0.5)*J*2;$.push([...M])}return $},$1=(V,J)=>{if(V.length===0)throw new Error("Cannot sample from empty array");if(J<=0)return[];if(J>=V.length)return[...V];let N=[],$=new Set;while(N.length<J){let M=h(0,V.length-1);if(!$.has(M))$.add(M),N.push(V[M])}return N},M1=(V,J,N)=>{let $=[];for(let M=0;M<N;M++)$.push(s0(V,J));return $};var q=(V,J)=>({x:V,y:J}),T=(V,J)=>{return u(V,J)},o0=(V,J)=>{let N=V.x-J.x,$=V.y-J.y;return N*N+$*$},l0=(V,J,N)=>{return{x:V.x+(J.x-V.x)*N,y:V.y+(J.y-V.y)*N}},i0=(V,J)=>{return Q8(J.y-V.y,J.x-V.x)},K1=(V,J)=>({width:V,height:J}),_1=(V)=>{return V.width*V.height},Z1=(V)=>{return 2*(V.width+V.height)},G1=(V)=>{return V.width/V.height},Z0=(V,J)=>({width:V.width*J,height:V.height*J}),Q1=(V,J)=>{let N=C(J.width/V.width,J.height/V.height);return Z0(V,N)},W1=(V,J)=>{let N=x(J.width/V.width,J.height/V.height);return Z0(V,N)},z=(V,J,N,$)=>({x:V,y:J,width:N,height:$}),E1=(V,J)=>{let N=C(V.x,J.x),$=C(V.y,J.y),M=s(J.x-V.x),K=s(J.y-V.y);return z(N,$,M,K)},X1=(V,J)=>{return z(V.x-J.width/2,V.y-J.height/2,J.width,J.height)},a0=(V)=>{return q(V.x+V.width/2,V.y+V.height/2)},q7=(V)=>{return q(V.x,V.y)},D7=(V)=>{return q(V.x+V.width,V.y)},H7=(V)=>{return q(V.x,V.y+V.height)},L7=(V)=>{return q(V.x+V.width,V.y+V.height)},Y1=(V)=>{return V.width*V.height},U1=(V)=>{return 2*(V.width+V.height)},F1=(V,J)=>{return z(V.x-J,V.y-J,V.width+2*J,V.height+2*J)},q1=(V,J)=>{let N=a0(V),$=V.width*J,M=V.height*J;return z(N.x-$/2,N.y-M/2,$,M)},D1=(V,J)=>{let N=C(V.x,J.x),$=C(V.y,J.y),M=x(V.x+V.width,J.x+J.width),K=x(V.y+V.height,J.y+J.height);return z(N,$,M-N,K-$)},H1=(V,J)=>{let N=x(V.x,J.x),$=x(V.y,J.y),M=C(V.x+V.width,J.x+J.width),K=C(V.y+V.height,J.y+J.height);if(N>=M||$>=K)return null;return z(N,$,M-N,K-$)},l=(V,J,N)=>({x:V,y:J,radius:N}),B7=(V,J,N)=>{let{x:$,y:M}=V,K=J.x,_=J.y,Z=N.x,G=N.y,Q=2*($*(_-G)+K*(G-M)+Z*(M-_));if(s(Q)<0.0000000001)return l(0,0,0);let W=(($*$+M*M)*(_-G)+(K*K+_*_)*(G-M)+(Z*Z+G*G)*(M-_))/Q,X=(($*$+M*M)*(Z-K)+(K*K+_*_)*($-Z)+(Z*Z+G*G)*(K-$))/Q,Y=T(q(W,X),V);return l(W,X,Y)},g=(V)=>{return q(V.x,V.y)},L1=(V)=>{return j*V.radius*V.radius},B1=(V)=>{return v*V.radius},j1=(V,J)=>{return q(V.x+V.radius*m(J),V.y+V.radius*k(J))},j7=(V,J)=>{let N=T(g(V),J);return l(V.x,V.y,x(V.radius,N))},R1=(V,J)=>{return V.x>=J.x&&V.x<=J.x+J.width&&V.y>=J.y&&V.y<=J.y+J.height},O1=(V,J)=>{return o0(V,g(J))<=J.radius*J.radius},P1=(V,J)=>{return V.x<J.x+J.width&&V.x+V.width>J.x&&V.y<J.y+J.height&&V.y+V.height>J.y},A1=(V,J)=>{return T(g(V),g(J))<=V.radius+J.radius},k1=(V,J)=>{let N=Math.max(J.x,Math.min(V.x,J.x+J.width)),$=Math.max(J.y,Math.min(V.y,J.y+J.height));return T(g(V),q(N,$))<=V.radius},I1=(V,J)=>({start:V,end:J}),T1=(V)=>{return T(V.start,V.end)},z1=(V)=>{return i0(V.start,V.end)},S1=(V,J)=>{return l0(V.start,V.end,J)},C1=(V)=>{let J=O(V.end,V.start),N=E(-J.y,J.x);return S(N)},w1=(V)=>{return S(O(V.end,V.start))},f1=(V,J)=>{let N=O(V.end,V.start),$=O(J,V.start),M=N.x*$.x+N.y*$.y,K=N.x*N.x+N.y*N.y;if(K===0)return T(V.start,J);let _=Math.max(0,Math.min(1,M/K)),Z=R(V.start,D(N,_));return T(Z,J)},v1=(V,J)=>{let N=V.start.x,$=V.start.y,M=V.end.x,K=V.end.y,_=J.start.x,Z=J.start.y,G=J.end.x,Q=J.end.y,W=(N-M)*(Z-Q)-($-K)*(_-G);if(s(W)<0.0000000001)return null;let X=((N-_)*(Z-Q)-($-Z)*(_-G))/W,Y=-((N-M)*($-Z)-($-K)*(N-_))/W;if(X>=0&&X<=1&&Y>=0&&Y<=1)return q(N+X*(M-N),$+X*(K-$));return null},x1=(...V)=>{if(V.length<3)throw new Error("Polygon must have at least 3 vertices");return V},b1=(V)=>{let J=0,N=V.length;for(let $=0;$<N;$++){let M=($+1)%N;J+=V[$].x*V[M].y,J-=V[M].x*V[$].y}return s(J)/2},u1=(V)=>{let J=0,N=0,$=V.length;for(let M=0;M<$;M++)J+=V[M].x,N+=V[M].y;return q(J/$,N/$)},m1=(V)=>{let J=0,N=V.length;for(let $=0;$<N;$++){let M=($+1)%N;J+=T(V[$],V[M])}return J},y1=(V,J)=>{let N=!1,$=J.length;for(let M=0,K=$-1;M<$;K=M++){let _=J[M].x,Z=J[M].y,G=J[K].x,Q=J[K].y;if(Z>V.y!==Q>V.y&&V.x<(G-_)*(V.y-Z)/(Q-Z)+_)N=!N}return N},h1=(V)=>{if(V.length===0)return z(0,0,0,0);let J=V[0].x,N=V[0].y,$=V[0].x,M=V[0].y;for(let K=1;K<V.length;K++)J=C(J,V[K].x),N=C(N,V[K].y),$=x($,V[K].x),M=x(M,V[K].y);return z(J,N,$-J,M-N)},i=(V,J,N,$=0)=>{if(N<3)throw new Error("Regular polygon must have at least 3 sides");let M=[],K=v/N;for(let _=0;_<N;_++){let Z=_*K+$;M.push(q(V.x+J*m(Z),V.y+J*k(Z)))}return M},g1=(V,J,N,$)=>{let M=1-V;return q(M*M*J.x+2*M*V*N.x+V*V*$.x,M*M*J.y+2*M*V*N.y+V*V*$.y)},p1=(V,J,N,$,M)=>{let K=1-V;return q(K*K*K*J.x+3*K*K*V*N.x+3*K*V*V*$.x+V*V*V*M.x,K*K*K*J.y+3*K*K*V*N.y+3*K*V*V*$.y+V*V*V*M.y)},d1=(V,J)=>{let N=[],$=Math.floor(V.width/J),M=Math.floor(V.height/J);for(let K=0;K<=M;K++)for(let _=0;_<=$;_++)N.push(q(V.x+_*J,V.y+K*J));return N},c1=(V,J,N)=>{let $=[V];for(let M=1;M<=N;M++)for(let K=0;K<6;K++)for(let _=0;_<M;_++){let Z=(K*60+_*60/M)*j/180,G=M*J;$.push(q(V.x+G*m(Z),V.y+G*k(Z)))}return $},r1=(V,J,N)=>[V,J,N],n1=(V,J)=>{let N=J/2;return[q(V.x-N,V.y-N),q(V.x+N,V.y-N),q(V.x+N,V.y+N),q(V.x-N,V.y+N)]},s1=(V,J)=>{return i(V,J,5)},o1=(V,J)=>{return i(V,J,6)},l1=(V,J)=>{return i(V,J,8)},i1=(V,J,N,$)=>{let M=[],K=v/($*2);for(let _=0;_<$*2;_++){let Z=_*K,G=_%2===0?J:N;M.push(q(V.x+G*m(Z),V.y+G*k(Z)))}return M};var a1=(V=1,J=9.81)=>E(0,V*J),t1=(V,J=0.1)=>D(V,-J),e1=(V,J=0.01)=>{let N=b(V);return D(S(V),-J*N*N)},G0=(V,J,N=1,$=1,M=1)=>{let K=O(J,V),_=b(K);if(_===0)return E(0,0);let Z=M*N*$/(_*_);return D(S(K),Z)},t0=(V,J,N=1,$=1,M=1)=>{let K=G0(V,J,N,$,M);return D(K,-1)},e0=(V,J,N,$=0.1,M=0.99)=>{let K=O(J,V),_=b(K),Z=_-N;if(_===0)return E(0,0);let G=Z*$;return D(S(K),G*M)};class Q0{position;velocity;acceleration;mass;lifetime;maxLifetime;isDead;constructor(V=0,J=0,N=0,$=0,M=1,K=1/0){this.position=E(V,J),this.velocity=E(N,$),this.acceleration=E(0,0),this.mass=M,this.lifetime=K,this.maxLifetime=K,this.isDead=!1}addForce(V){let J=D(V,1/this.mass);this.acceleration=R(this.acceleration,J)}update(V=1){if(this.velocity=R(this.velocity,D(this.acceleration,V)),this.position=R(this.position,D(this.velocity,V)),this.acceleration=E(0,0),this.lifetime!==1/0){if(this.lifetime-=V,this.lifetime<=0)this.isDead=!0}}distanceTo(V){return u(this.position,V.position)}attractTo(V,J=1){let N=G0(this.position,V.position,this.mass,V.mass,J);this.addForce(N)}repelFrom(V,J=1){let N=t0(this.position,V.position,this.mass,V.mass,J);this.addForce(N)}applySpring(V,J=0,N=0.1){let $=e0(this.position,V,J,N);this.addForce($)}getAge(){return this.maxLifetime-this.lifetime}getAgeRatio(){if(this.maxLifetime===1/0)return 0;return this.getAge()/this.maxLifetime}}class VV{particles;forces;constructor(){this.particles=[],this.forces=[]}addParticle(V){this.particles.push(V)}addForce(V){this.forces.push(V)}update(V=1){for(let J=0;J<this.particles.length;J++){let N=this.particles[J];for(let $ of this.forces)N.addForce($(N,J,this.particles));N.update(V)}this.particles=this.particles.filter((J)=>!J.isDead)}getParticles(){return this.particles}getAliveCount(){return this.particles.length}clear(){this.particles=[]}}class W0{position;oldPosition;acceleration;mass;pinned;constructor(V=0,J=0,N=1){this.position=E(V,J),this.oldPosition=E(V,J),this.acceleration=E(0,0),this.mass=N,this.pinned=!1}addForce(V){let J=D(V,1/this.mass);this.acceleration=R(this.acceleration,J)}update(V=1){if(this.pinned)return;let J=O(this.position,this.oldPosition);this.oldPosition={...this.position};let N=V*V,$=D(this.acceleration,N);this.position=R(R(this.position,J),$),this.acceleration=E(0,0)}pin(){this.pinned=!0}unpin(){this.pinned=!1}}class a{p1;p2;restLength;stiffness;constructor(V,J,N=1){this.p1=V,this.p2=J,this.restLength=u(V.position,J.position),this.stiffness=N}update(){let V=O(this.p2.position,this.p1.position),J=b(V);if(J===0)return;let N=(this.restLength-J)/J,$=D(V,N*0.5*this.stiffness);if(!this.p1.pinned)this.p1.position=O(this.p1.position,$);if(!this.p2.pinned)this.p2.position=R(this.p2.position,$)}}class JV{particles;constraints;width;height;constructor(V,J,N=10,$=1){this.width=V,this.height=J,this.particles=[],this.constraints=[];let M=Math.floor(V/N),K=Math.floor(J/N);for(let _=0;_<=K;_++){this.particles[_]=[];for(let Z=0;Z<=M;Z++){let G=Z/M*V,Q=_/K*J;this.particles[_][Z]=new W0(G,Q)}}for(let _=0;_<=K;_++)for(let Z=0;Z<=M;Z++){let G=this.particles[_][Z];if(Z<M)this.constraints.push(new a(G,this.particles[_][Z+1],$));if(_<K)this.constraints.push(new a(G,this.particles[_+1][Z],$))}}update(){for(let V of this.particles)for(let J of V)J.update();for(let V=0;V<3;V++)for(let J of this.constraints)J.update()}pinCorners(){let V=this.particles.length-1,J=this.particles[0].length-1;this.particles[0][0].pin(),this.particles[0][J].pin()}addWind(V){for(let J of this.particles)for(let N of J)N.addForce(V)}addGravity(V=0.1){for(let J of this.particles)for(let N of J)N.addForce(E(0,V))}}var V8=(V,J,N,$=0)=>{let M=V.x+Math.cos($)*J,K=V.y+Math.sin($)*J,_=-Math.sin($)*N,Z=Math.cos($)*N;return{position:E(M,K),velocity:E(_,Z)}},J8=(V,J,N=1,$=5,M=100)=>{let K=[];for(let _=0;_<J;_++){let Z=_/J*Math.PI*2,G=N+Math.random()*($-N),Q=Math.cos(Z)*G,W=Math.sin(Z)*G;K.push(new Q0(V.x,V.y,Q,W,1,M+Math.random()*M*0.5))}return K};class w{axiom;rules;current;generation;constructor(V,J=[]){this.axiom=V,this.rules=new Map,this.current=V,this.generation=0;for(let N of J)this.rules.set(N.symbol,N.replacement)}addRule(V,J){this.rules.set(V,J)}iterate(V=1){for(let J=0;J<V;J++){let N="";for(let $ of this.current)N+=this.rules.get($)||$;this.current=N,this.generation++}return this.current}reset(){this.current=this.axiom,this.generation=0}getString(){return this.current}getGeneration(){return this.generation}}class NV{position;angle;stack;path;penDown;constructor(V=0,J=0,N=0){this.position=E(V,J),this.angle=N,this.stack=[],this.path=[],this.penDown=!0}forward(V){let J=R(this.position,E(Math.cos(this.angle)*V,Math.sin(this.angle)*V));if(this.penDown)this.path.push({...this.position}),this.path.push({...J});this.position=J}turn(V){this.angle+=V}turnLeft(V){this.turn(-V)}turnRight(V){this.turn(V)}push(){this.stack.push({position:{...this.position},angle:this.angle})}pop(){let V=this.stack.pop();if(V)this.position=V.position,this.angle=V.angle}penUp(){this.penDown=!1}penDownFn(){this.penDown=!0}getPath(){return this.path}reset(V=0,J=0,N=0){this.position=E(V,J),this.angle=N,this.stack=[],this.path=[],this.penDown=!0}}var N8={koch:new w("F",[{symbol:"F",replacement:"F+F-F-F+F"}]),sierpinski:new w("F-G-G",[{symbol:"F",replacement:"F-G+F+G-F"},{symbol:"G",replacement:"GG"}]),dragon:new w("FX",[{symbol:"X",replacement:"X+YF+"},{symbol:"Y",replacement:"-FX-Y"}]),plant:new w("X",[{symbol:"X",replacement:"F+[[X]-X]-F[-FX]+X"},{symbol:"F",replacement:"FF"}]),tree:new w("F",[{symbol:"F",replacement:"F[+F]F[-F]F"}]),cantor:new w("F",[{symbol:"F",replacement:"F F"},{symbol:" ",replacement:"   "}])};class $V{commands;defaultAngle;defaultDistance;constructor(V=60,J=10){this.commands=new Map,this.defaultAngle=t(V),this.defaultDistance=J,this.addCommand("F",(N)=>N.forward(this.defaultDistance)),this.addCommand("G",(N)=>N.forward(this.defaultDistance)),this.addCommand("+",(N)=>N.turnLeft(this.defaultAngle)),this.addCommand("-",(N)=>N.turnRight(this.defaultAngle)),this.addCommand("[",(N)=>N.push()),this.addCommand("]",(N)=>N.pop())}addCommand(V,J){this.commands.set(V,J)}interpret(V,J){for(let N of V){let $=this.commands.get(N);if($)$(J)}return J.getPath()}draw(V,J,N){return V.iterate(J),this.interpret(V.getString(),N)}}var MV=(V,J=100)=>{let N={real:0,imag:0},$=0;while($<J){let M=N.real*N.real-N.imag*N.imag+V.real,K=2*N.real*N.imag+V.imag;if(N.real=M,N.imag=K,N.real*N.real+N.imag*N.imag>4)break;$++}return $},$8=(V,J,N=-2.5,$=1.5,M=-2,K=2,_=100)=>{let Z=[];for(let G=0;G<J;G++){Z[G]=[];for(let Q=0;Q<V;Q++){let W=N+Q/V*($-N),X=M+G/J*(K-M);Z[G][Q]=MV({real:W,imag:X},_)}}return Z},KV=(V,J,N=100)=>{let $=0;while($<N){let M=V.real*V.real-V.imag*V.imag+J.real,K=2*V.real*V.imag+J.imag;if(V.real=M,V.imag=K,V.real*V.real+V.imag*V.imag>4)break;$++}return $},M8=(V,J,N,$=-2,M=2,K=-2,_=2,Z=100)=>{let G=[];for(let Q=0;Q<J;Q++){G[Q]=[];for(let W=0;W<V;W++){let X=$+W/V*(M-$),Y=K+Q/J*(_-K);G[Q][W]=KV({real:X,imag:Y},N,Z)}}return G},K8=(V,J,N)=>{if(V.length<3)throw new Error("Need at least 3 vertices");let $=[],M=N||{x:(V[0].x+V[1].x+V[2].x)/3,y:(V[0].y+V[1].y+V[2].y)/3};for(let K=0;K<J;K++){let _=V[Math.floor(Math.random()*V.length)];M={x:(M.x+_.x)/2,y:(M.y+_.y)/2},$.push({...M})}return $},_8=(V)=>{let J=[],N=0,$=0;for(let M=0;M<V;M++){let K=Math.random(),_,Z;if(K<0.01)_=0,Z=0.16*$;else if(K<0.86)_=0.85*N+0.04*$,Z=-0.04*N+0.85*$+1.6;else if(K<0.93)_=0.2*N-0.26*$,Z=0.23*N+0.22*$+1.6;else _=-0.15*N+0.28*$,Z=0.26*N+0.24*$+0.44;N=_,$=Z,J.push({x:N,y:$})}return J},f=(V,J,N)=>{if(N===0)return[V,J];let $=J.x-V.x,M=J.y-V.y,K=V,_={x:V.x+$/3,y:V.y+M/3},Z={x:V.x+2*$/3,y:V.y+2*M/3},G=J,Q=(_.x+Z.x)/2,W=(_.y+Z.y)/2,X=Math.atan2(M,$)-Math.PI/2,Y=Math.sqrt($*$+M*M)/(2*Math.sqrt(3)),p={x:Q+Math.cos(X)*Y,y:W+Math.sin(X)*Y};return[...f(K,_,N-1).slice(0,-1),...f(_,p,N-1).slice(0,-1),...f(p,Z,N-1).slice(0,-1),...f(Z,G,N-1)]},Z8=(V,J,N)=>{let $=[{x:V.x+J*Math.cos(0),y:V.y+J*Math.sin(0)},{x:V.x+J*Math.cos(2*Math.PI/3),y:V.y+J*Math.sin(2*Math.PI/3)},{x:V.x+J*Math.cos(4*Math.PI/3),y:V.y+J*Math.sin(4*Math.PI/3)}];return[...f($[0],$[1],N).slice(0,-1),...f($[1],$[2],N).slice(0,-1),...f($[2],$[0],N)]},E0=(V,J,N,$,M=Math.PI/6,K=0.7)=>{let _={x:V.x+Math.cos(J)*N,y:V.y+Math.sin(J)*N},Z=[[V,_]];if($>0){let G=E0(_,J-M,N*K,$-1,M,K),Q=E0(_,J+M,N*K,$-1,M,K);Z.push(...G,...Q)}return Z};class n{static instance;animationLoop;canvas;context;constructor(){this.animationLoop=new J0}get width(){return this.canvas?.width??0}get height(){return this.canvas?.height??0}static getInstance(){if(!n.instance)n.instance=new n;return n.instance}setCanvas(V){this.canvas=V;let J=V.getContext("2d");this.context=J??void 0}getCanvas(){return this.canvas}getContext(){return this.context}start(V){return this.animationLoop.onFrame(V)}play(){this.animationLoop.start()}pause(){this.animationLoop.stop()}clear(V){if(!this.context||!this.canvas)return;if(this.context.clearRect(0,0,this.canvas.width,this.canvas.height),V){let J=this.context.fillStyle;this.context.fillStyle=this.convertColor(V),this.context.fillRect(0,0,this.canvas.width,this.canvas.height),this.context.fillStyle=J}}background(V){this.clear(V)}setStroke(V,J=1){if(!this.context)return;this.context.strokeStyle=this.convertColor(V),this.context.lineWidth=J}fill(V){if(!this.context)return;this.context.fillStyle=this.convertColor(V)}convertColor(V){if(typeof V==="string")return V;if(V&&typeof V.r==="number"&&typeof V.g==="number"&&typeof V.b==="number"){if(typeof V.a==="number")return B0(V);return L0(V)}if(V&&typeof V.h==="number"&&typeof V.s==="number"&&typeof V.l==="number"){if(typeof V.a==="number")return R0(V);return j0(V)}return"#000000"}noStroke(){if(!this.context)return;this.context.strokeStyle="transparent"}noFill(){if(!this.context)return;this.context.fillStyle="transparent"}drawCircle(V,J,N,$=!0){if(!this.context)return;if(this.context.beginPath(),this.context.arc(V,J,N,0,v),$)this.context.fill();else this.context.stroke()}drawRect(V,J,N,$,M=!0){if(!this.context)return;if(M)this.context.fillRect(V,J,N,$);else this.context.strokeRect(V,J,N,$)}drawLine(V,J,N,$){if(!this.context)return;this.context.beginPath(),this.context.moveTo(V,J),this.context.lineTo(N,$),this.context.stroke()}drawPolygon(V,J=!0){if(!this.context||V.length<3)return;this.context.beginPath(),this.context.moveTo(V[0].x,V[0].y);for(let N=1;N<V.length;N++)this.context.lineTo(V[N].x,V[N].y);if(this.context.closePath(),J)this.context.fill();else this.context.stroke()}drawText(V,J,N,$){if(!this.context)return;if($)this.context.font=$;this.context.fillText(V,J,N)}translate(V,J){if(!this.context)return;this.context.translate(V,J)}rotate(V){if(!this.context)return;this.context.rotate(V)}scale(V,J=V){if(!this.context)return;this.context.scale(V,J)}pushMatrix(){if(!this.context)return;this.context.save()}popMatrix(){if(!this.context)return;this.context.restore()}rect(V,J,N,$){this.drawRect(V,J,N,$,!0)}circle(V,J,N){this.drawCircle(V,J,N,!0)}line(V,J,N,$){this.drawLine(V,J,N,$)}polygon(V){this.drawPolygon(V,!0)}text(V,J,N,$){if(!this.context)return;let M="";if($?.weight)M+=$.weight+" ";if($?.size)M+=$.size+"px ";if($?.family)M+=$.family;else M+="Arial, sans-serif";if(this.context.font=M.trim(),$?.align)this.context.textAlign=$.align;this.context.fillText(V,J,N)}strokeWeight(V){if(!this.context)return;this.context.lineWidth=V}beginPath(){if(!this.context)return;this.context.beginPath()}moveTo(V,J){if(!this.context)return;this.context.moveTo(V,J)}lineTo(V,J){if(!this.context)return;this.context.lineTo(V,J)}stroke(){if(!this.context)return;this.context.stroke()}}var G8=n.getInstance(),I8=(V)=>{return G8.setCanvas(V),G8},W8="1.0.0",T8={name:"play.ts",version:W8,description:"A TypeScript library for creative coding",author:"play.ts team",license:"MIT",modules:{math:"Mathematical utilities including vectors, matrices, and interpolation",color:"Color manipulation and conversion utilities",animation:"Easing functions and animation utilities",random:"Random number generation and noise functions",geometry:"Geometric shapes and collision detection",physics:"Physics simulation with forces, particles, and constraints",fractals:"Fractal generation, L-Systems, and procedural patterns"}},u7={math:{clamp:U,lerp:B,map:GV,normalize:QV,vec2:E,vec2Add:R,vec2Sub:O,vec2Mul:D,vec2Div:EV,vec2Length:b,vec2Normalize:S,vec2Distance:u,vec2Angle:XV,vec2FromAngle:YV,vec2Lerp:UV,vec2Rotate:FV,vec3:Y0,vec3Add:qV,vec3Sub:U0,vec3Mul:DV,vec3Div:F0,vec3Length:e,vec3Normalize:BV,vec3Distance:jV,vec3Lerp:RV,vec3Cross:LV,vec3Dot:HV,PI:j,TWO_PI:v,HALF_PI:_V,TAU:ZV,degrees:WV,radians:t},color:{rgb:F,rgba:q0,hsl:H,hsla:OV,rgbToHsl:I,hslToRgb:L,rgbToHex:PV,hexToRgb:AV,colorLerp:kV,colorLerpHsl:IV,brighten:D0,darken:TV,saturate:H0,desaturate:zV,hueShift:SV,grayscale:CV,invert:wV,complementary:fV,triadic:vV,analogous:xV,colors:bV,toCssRgb:L0,toCssRgba:B0,toCssHsl:j0,toCssHsla:R0},animation:{linear:c,easeInQuad:O0,easeOutQuad:P0,easeInOutQuad:A0,easeInCubic:k0,easeOutCubic:I0,easeInOutCubic:T0,easeInSine:z0,easeOutSine:S0,easeInOutSine:C0,easeInExpo:w0,easeOutExpo:f0,easeInOutExpo:v0,easeInCirc:x0,easeOutCirc:b0,easeInOutCirc:u0,easeInBack:m0,easeOutBack:y0,easeInOutBack:h0,easeInElastic:g0,easeOutElastic:p0,easeInOutElastic:d0,easeInBounce:c0,easeOutBounce:d,easeInOutBounce:r0,easings:mV,AnimationLoop:J0,Tween:N0,tween:n0,animate:hV,Spring:$0,spring:gV,delay:yV},random:{SeededRandom:o,SimpleNoise:M0,FractalNoise:K0,PerlinNoise:_0,random:A,noise:pV,fractalNoise:dV,randomInt:h,randomFloat:r,randomBool:cV,randomChoice:rV,randomSign:nV,randomAngle:sV,randomInCircle:oV,randomOnCircle:lV,randomGaussian:iV,setSeed:aV,weightedChoice:s0,shuffle:tV,randomColor:eV,randomColorHSL:V1,randomDistribution:J1,randomWalk:N1,sample:$1,sampleWeighted:M1},geometry:{point:q,pointDistance:T,pointDistanceSq:o0,pointLerp:l0,pointAngle:i0,size:K1,sizeArea:_1,sizePerimeter:Z1,sizeAspectRatio:G1,sizeScale:Z0,sizeFit:Q1,sizeFill:W1,rect:z,rectFromPoints:E1,rectFromCenter:X1,rectCenter:a0,rectArea:Y1,rectPerimeter:U1,rectExpand:F1,rectScale:q1,rectUnion:D1,rectIntersection:H1,circle:l,circleCenter:g,circleArea:L1,circleCircumference:B1,circlePointAt:j1,pointInRect:R1,pointInCircle:O1,rectIntersects:P1,circleIntersects:A1,circleRectIntersects:k1,line:I1,lineLength:T1,lineAngle:z1,linePointAt:S1,lineNormal:C1,lineDirection:w1,lineDistanceToPoint:f1,lineIntersection:v1,polygon:x1,polygonArea:b1,polygonCentroid:u1,polygonPerimeter:m1,pointInPolygon:y1,polygonBoundingBox:h1,regularPolygon:i,quadraticBezier:g1,cubicBezier:p1,gridPoints:d1,hexGrid:c1,triangle:r1,square:n1,pentagon:s1,hexagon:o1,octagon:l1,star:i1},physics:{Particle:Q0,ParticleSystem:VV,VerletParticle:W0,VerletConstraint:a,Cloth:JV,gravity:a1,friction:t1,drag:e1,attraction:G0,repulsion:t0,springForce:e0,createOrbit:V8,createExplosion:J8},fractals:{LSystem:w,Turtle:NV,LSystemInterpreter:$V,lSystems:N8,mandelbrot:MV,mandelbrotSet:$8,julia:KV,juliaSet:M8,sierpinskiTriangle:K8,barnsleyFern:_8,kochSnowflake:f,createKochSnowflake:Z8,fractalTree:E0},Play:n,play:G8,setup:I8,version:W8,info:T8};export{b8 as wrap,s0 as weightedChoice,W8 as version,U0 as vec3Sub,BV as vec3Normalize,DV as vec3Mul,RV as vec3Lerp,y8 as vec3LengthSq,e as vec3Length,HV as vec3Dot,F0 as vec3Div,jV as vec3Distance,LV as vec3Cross,qV as vec3Add,Y0 as vec3,O as vec2Sub,FV as vec2Rotate,S as vec2Normalize,D as vec2Mul,UV as vec2Lerp,m8 as vec2LengthSq,b as vec2Length,YV as vec2FromAngle,u8 as vec2Dot,EV as vec2Div,u as vec2Distance,XV as vec2Angle,R as vec2Add,E as vec2,n0 as tween,e8 as trunc,r1 as triangle,vV as triadic,B0 as toCssRgba,L0 as toCssRgb,R0 as toCssHsla,j0 as toCssHsl,G7 as tetradic,i8 as tanh,c8 as tan,i1 as star,n1 as square,V0 as sqrt,e0 as springForce,gV as spring,Z7 as splitComplementary,w8 as smoothstep,f8 as smootherstep,Z0 as sizeScale,Z1 as sizePerimeter,Q1 as sizeFit,W1 as sizeFill,G1 as sizeAspectRatio,_1 as sizeArea,K1 as size,o8 as sinh,k as sin,v8 as sign,K8 as sierpinskiTriangle,tV as shuffle,I8 as setup,aV as setSeed,H0 as saturate,M1 as sampleWeighted,$1 as sample,t8 as round,q0 as rgba,I as rgbToHsl,PV as rgbToHex,F as rgb,t0 as repulsion,i as regularPolygon,D1 as rectUnion,D7 as rectTopRight,q7 as rectTopLeft,q1 as rectScale,U1 as rectPerimeter,P1 as rectIntersects,H1 as rectIntersection,E1 as rectFromPoints,X1 as rectFromCenter,F1 as rectExpand,a0 as rectCenter,L7 as rectBottomRight,H7 as rectBottomLeft,Y1 as rectArea,z as rect,N1 as randomWalk,nV as randomSign,lV as randomOnCircle,h as randomInt,oV as randomInCircle,iV as randomGaussian,r as randomFloat,J1 as randomDistribution,V1 as randomColorHSL,eV as randomColor,rV as randomChoice,cV as randomBool,sV as randomAngle,A as random,t as radians,g1 as quadraticBezier,P as pow,m1 as polygonPerimeter,u1 as polygonCentroid,h1 as polygonBoundingBox,b1 as polygonArea,x1 as polygon,l0 as pointLerp,R1 as pointInRect,y1 as pointInPolygon,O1 as pointInCircle,o0 as pointDistanceSq,T as pointDistance,i0 as pointAngle,q as point,G8 as play,s1 as pentagon,l1 as octagon,QV as normalize,pV as noise,C as min,x as max,d8 as mat3TransformVec2,p8 as mat3Multiply,h8 as mat3Identity,g8 as mat3FromValues,GV as map,$8 as mandelbrotSet,MV as mandelbrot,N7 as log2,$7 as log10,J7 as log,c as linear,S1 as linePointAt,C1 as lineNormal,T1 as lineLength,v1 as lineIntersection,f1 as lineDistanceToPoint,w1 as lineDirection,z1 as lineAngle,I1 as line,B as lerp,N8 as lSystems,f as kochSnowflake,M8 as juliaSet,KV as julia,wV as invert,T8 as info,SV as hueShift,OV as hsla,L as hslToRgb,H as hsl,o1 as hexagon,AV as hexToRgb,c1 as hexGrid,d1 as gridPoints,CV as grayscale,a1 as gravity,t1 as friction,E0 as fractalTree,dV as fractalNoise,x8 as fract,y as floor,V7 as exp,mV as easings,S0 as easeOutSine,P8 as easeOutQuint,j8 as easeOutQuart,P0 as easeOutQuad,f0 as easeOutExpo,p0 as easeOutElastic,I0 as easeOutCubic,b0 as easeOutCirc,d as easeOutBounce,y0 as easeOutBack,z0 as easeInSine,O8 as easeInQuint,B8 as easeInQuart,O0 as easeInQuad,C0 as easeInOutSine,A8 as easeInOutQuint,R8 as easeInOutQuart,A0 as easeInOutQuad,v0 as easeInOutExpo,d0 as easeInOutElastic,T0 as easeInOutCubic,u0 as easeInOutCirc,r0 as easeInOutBounce,h0 as easeInOutBack,w0 as easeInExpo,g0 as easeInElastic,k0 as easeInCubic,x0 as easeInCirc,c0 as easeInBounce,m0 as easeInBack,e1 as drag,zV as desaturate,yV as delay,WV as degrees,u7 as default,TV as darken,p1 as cubicBezier,V8 as createOrbit,Z8 as createKochSnowflake,J8 as createExplosion,k8 as createAnimationFrame,l8 as cosh,m as cos,_7 as contrast,fV as complementary,bV as colors,Q7 as colorSimilarity,IV as colorLerpHsl,kV as colorLerp,L8 as colorDistance,U as clamp,k1 as circleRectIntersects,j1 as circlePointAt,A1 as circleIntersects,B7 as circleFromPoints,j7 as circleExpandToPoint,B1 as circleCircumference,g as circleCenter,L1 as circleArea,l as circle,a8 as ceil,D0 as brighten,_8 as barnsleyFern,G0 as attraction,Q8 as atan2,s8 as atan,r8 as asin,hV as animate,xV as analogous,n8 as acos,s as abs,W0 as VerletParticle,a as VerletConstraint,N0 as Tween,NV as Turtle,v as TWO_PI,ZV as TAU,$0 as Spring,M0 as SimpleNoise,o as SeededRandom,z8 as QUARTER_PI,n as Play,_0 as PerlinNoise,VV as ParticleSystem,Q0 as Particle,j as PI,C8 as PHI,$V as LSystemInterpreter,w as LSystem,_V as HALF_PI,K0 as FractalNoise,S8 as E,JV as Cloth,J0 as AnimationLoop};
